

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>generalizit.design &mdash; GeneralizIT 0.1.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=92734c54"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GeneralizIT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GeneralizIT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">generalizit.design</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for generalizit.design</h1><div class="highlight"><pre>
<span></span><span class="c1"># -------------------------------- #</span>
<span class="c1"># Description:</span>
<span class="c1"># This is the analytical engine for the Generalizability Theory (G-Theory) calculations.</span>
<span class="c1"># It calculates variance components, G-coefficients, and other related statistics.</span>
<span class="c1"># -------------------------------- #</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">generalizit.g_theory_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_pseudo_df</span>

<div class="viewcode-block" id="Design">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Design</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">variance_tuple_dictionary</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">response_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">missing_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">variance_tuple_dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">missing_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">response_col</span>

        <span class="c1"># Initialize the tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_coeffs_table</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        
        <span class="c1"># Initialize the dictionaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variances</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_study_dict</span><span class="p">:</span> <span class="nb">dict</span>  <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Initialize alpha for confidence intervals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_levels_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the levels coefficients for variance components based on grouping combinations.</span>
<span class="sd">    </span>
<span class="sd">        This method calculates the levels coefficients used to adjust variance components</span>
<span class="sd">        in Generalizability Theory. It processes the provided data to compute grouping</span>
<span class="sd">        combinations and their respective harmonic means, storing the results in a levels</span>
<span class="sd">        coefficients DataFrame.</span>
<span class="sd">    </span>
<span class="sd">        Parameters:</span>
<span class="sd">            **kwargs: Optional keyword arguments.</span>
<span class="sd">                - df (pd.DataFrame): A custom DataFrame to use for calculations. If not provided,</span>
<span class="sd">                  the default `self.data` is used.</span>
<span class="sd">                - variance_tuple_dictionary (dict): Custom variance tuple dictionary.</span>
<span class="sd">                  If not provided, self.variance_tuple_dictionary is used.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A DataFrame containing the levels coefficients, where rows and columns</span>
<span class="sd">                        correspond to facets. Values represent inverse level coefficients (1/n_i).</span>
<span class="sd">    </span>
<span class="sd">        Notes:</span>
<span class="sd">            - The method automatically identifies the facet with the maximum grouping variables</span>
<span class="sd">              and assigns a coefficient of 1 to all entries in its row.</span>
<span class="sd">            - The &quot;mean&quot; facet is excluded from calculation.</span>
<span class="sd">            - For unbalanced designs, harmonic means are used to calculate appropriate coefficients.</span>
<span class="sd">            - Values in the returned DataFrame represent the inverse of the effective sample size (1/n_i).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Use the provided DataFrame or default to self.data </span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">variance_tup_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;variance_tuple_dictionary&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">)</span>
        

        <span class="c1"># Step 2: Initialize levels coefficients table with variance components as index and columns</span>
        <span class="n">levels_coeffs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Drop the &quot;mean&quot; facet from rows and columns</span>
        <span class="n">levels_coeffs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">levels_coeffs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Step 3: Handle missing data if applicable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_data</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

        <span class="c1"># Step 4: Identify the facet with the maximum grouping variables</span>
        <span class="n">max_facet</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>

        <span class="c1"># Step 5: Iterate through each variance component to calculate levels coefficients</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differentiation_vars</span> <span class="ow">in</span> <span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">max_facet</span><span class="p">:</span>
                <span class="n">levels_coeffs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">facet_of_differentiation_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">differentiation_vars</span><span class="p">)</span>

            <span class="c1"># Iterate through each grouping facet to calculate levels</span>
            <span class="k">for</span> <span class="n">grouping_facet</span><span class="p">,</span> <span class="n">grouping_vars</span> <span class="ow">in</span> <span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">grouping_facet</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">grouping_columns</span> <span class="o">=</span> <span class="n">facet_of_differentiation_list</span> <span class="o">+</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">grouping_vars</span> <span class="k">if</span>
                                                                    <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">facet_of_differentiation_list</span><span class="p">]</span>

                <span class="c1"># Step 6: Count the occurrences of each grouping combination</span>
                <span class="n">counts_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">grouping_columns</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">facet_of_differentiation_list</span><span class="p">:</span>
                    <span class="c1"># Step 7: Calculate metrics in a single groupby operation</span>
                    <span class="n">grouped</span> <span class="o">=</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">facet_of_differentiation_list</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span>
                        <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>
                    <span class="p">})</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                    <span class="c1"># Rename columns for clarity</span>
                    <span class="n">grouped</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">facet_of_differentiation_list</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;sum_squared&#39;</span><span class="p">,</span> <span class="s1">&#39;sum_of_squares&#39;</span><span class="p">]</span>

                    <span class="c1"># Step 8: Calculate the ratio of sum_squared to sum_of_squares</span>
                    <span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;ratio&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;sum_squared&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;sum_of_squares&#39;</span><span class="p">]</span>

                    <span class="c1"># Step 9: Calculate the harmonic mean of the ratio</span>
                    <span class="n">inverse_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;ratio&#39;</span><span class="p">])</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">inverse_level</span>

                    <span class="c1"># Store the calculated level in the levels coefficients table</span>
                    <span class="n">levels_coeffs</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">grouping_facet</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_level</span>

        <span class="k">return</span> <span class="n">levels_coeffs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_degrees_of_freedom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED since v0.1.0: This method is no longer supported.</span>
<span class="sd">        </span>
<span class="sd">        This method was originally intended to calculate degrees of freedom for variance components</span>
<span class="sd">        but is no longer used in the current implementation of G-Theory calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_T_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the uncorrected sum of squares (T values) for each variance component.</span>

<span class="sd">        This method computes the T values for each entry in the variance tuple dictionary by:</span>
<span class="sd">        1. For components with effect variables: Groups the data by those variables, </span>
<span class="sd">           calculates the mean and count for each group, and sums the squared means </span>
<span class="sd">           multiplied by their group sizes.</span>
<span class="sd">        2. For the mean component (empty effect variables): Calculates the T value </span>
<span class="sd">           using the overall mean and count of the entire dataset.</span>

<span class="sd">        The results are stored in the `self.T` dictionary, with keys matching those in </span>
<span class="sd">        `self.variance_tuple_dictionary`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: Updates `self.T` in place with the calculated T values.</span>

<span class="sd">        Example:</span>
<span class="sd">            If the variance tuple dictionary contains {&#39;p&#39;: (&#39;p&#39;,), &#39;i&#39;: (&#39;i&#39;,), &#39;mean&#39;: ()},</span>
<span class="sd">            `self.T` will be populated with T values for &#39;p&#39;, &#39;i&#39;, and &#39;mean&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">effect_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">effect_vars</span><span class="p">:</span>
                    <span class="c1"># Group the DataFrame by the specified effect variables and calculate group mean and size</span>
                    <span class="n">t_calc_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">effect_vars</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">response_col</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">]})</span>

                    <span class="c1"># Flatten the MultiIndex columns to single level for easier access</span>
                    <span class="n">t_calc_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">t_calc_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">droplevel</span><span class="p">()</span>

                    <span class="c1"># Reset the index to make grouped columns part of the DataFrame again</span>
                    <span class="n">t_calc_df</span> <span class="o">=</span> <span class="n">t_calc_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                    <span class="c1"># Calculate the T value for each group: (mean^2) * count</span>
                    <span class="n">t_calc_df</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_calc_df</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">t_calc_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>

                    <span class="c1"># Return the total uncorrected sum of squares by summing the T values</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_calc_df</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Mean calculations if no effect variables are provided</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Calculate the overall mean and count for the entire DataFrame</span>
                    <span class="n">mean</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">response_col</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">response_col</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

                    <span class="c1"># Return the T value for the overall mean: (mean^2) * count</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">count</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error calculating T values: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Round the T values to 4 decimal places</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_sums_of_squares</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED since v0.1.0: This method is no longer supported.</span>
<span class="sd">        </span>
<span class="sd">        This method was originally intended to calculate sums of squares for variance components</span>
<span class="sd">        but is no longer used in the current implementation of G-Theory calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_mean_squares</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED since v0.1.0: This method is no longer supported.</span>
<span class="sd">        </span>
<span class="sd">        This method was originally intended to calculate mean squares for variance components</span>
<span class="sd">        but is no longer used in the current implementation of G-Theory calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_variance_coefficients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">grouping_vars</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">facets</span><span class="p">:</span> <span class="nb">list</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the variance or mean coefficient for a dataset based on grouped occurrences.</span>

<span class="sd">        This function computes a variance coefficient based on the squared sum of counts</span>
<span class="sd">        for each grouping variable, normalized by the total count for each group (or overall,</span>
<span class="sd">        if no facets are provided). It generalizes the calculation for both variance coefficients</span>
<span class="sd">        (based on grouping facets) and mean coefficients (entire dataset).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            df (pd.DataFrame): Input dataset containing the relevant variables.</span>
<span class="sd">            grouping_vars (list): List of column names used for grouping counts (`variances`).</span>
<span class="sd">            facets (list): List of column names defining additional grouping levels (`facets`).</span>
<span class="sd">                           If empty, the coefficient is calculated across the entire dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The computed variance or mean coefficient.</span>

<span class="sd">        Example:</span>
<span class="sd">            # Variance Coefficient</span>
<span class="sd">            calculate_variance_coefficient(df, grouping_vars=[&#39;i&#39;], facets=[&#39;d&#39;, &#39;p&#39;])</span>

<span class="sd">            # Mean Coefficient</span>
<span class="sd">            calculate_variance_coefficient(df, grouping_vars=[&#39;i&#39;], facets=[])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Mean facet and mean variance coefficient is the size of the dataset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grouping_vars</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>  <span class="c1"># No grouping variables: Return the total count of rows</span>

        <span class="c1"># Prepare the list of grouping columns</span>
        <span class="n">grouping_columns</span> <span class="o">=</span> <span class="n">facets</span><span class="p">[:]</span>  <span class="c1"># Copy the facets list to avoid modifying the original</span>
        <span class="k">for</span> <span class="n">variance</span> <span class="ow">in</span> <span class="n">grouping_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variance</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grouping_columns</span><span class="p">:</span>
                <span class="n">grouping_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>

        <span class="c1"># Step 1: Count the occurrences of each grouping combination</span>
        <span class="n">counts_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">grouping_columns</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">facets</span><span class="p">:</span>
            <span class="c1"># Step 2: Sum the total counts for each facet group</span>
            <span class="n">total_counts_df</span> <span class="o">=</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">facets</span><span class="p">)[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;total_count&#39;</span><span class="p">)</span>

            <span class="c1"># Step 3: Merge total counts with individual counts</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">total_counts_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">facets</span><span class="p">)</span>

            <span class="c1"># Step 4: Calculate the squared count divided by the total count for each group</span>
            <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;squared_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">merged_df</span><span class="p">[</span><span class="s1">&#39;total_count&#39;</span><span class="p">]</span>

            <span class="c1"># Step 5: Sum the squared terms for each facet group and return the overall sum</span>
            <span class="n">result_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">facets</span><span class="p">)[</span><span class="s1">&#39;squared_term&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;squared_term&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Facets are empty: Compute mean coefficient for the entire dataset</span>
            <span class="n">total_count</span> <span class="o">=</span> <span class="n">counts_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">counts_df</span><span class="p">[</span><span class="s1">&#39;squared_term&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">counts_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_count</span>

            <span class="c1"># Sum the squared terms and return</span>
            <span class="k">return</span> <span class="n">counts_df</span><span class="p">[</span><span class="s1">&#39;squared_term&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_variance_coefficients_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a variance coefficient matrix based on groupings defined in a variance tuple dictionary.</span>

<span class="sd">        This function computes variance coefficients for each pair of variance components and</span>
<span class="sd">        returns the results in a DataFrame.</span>

<span class="sd">        Attributes:</span>
<span class="sd">            data (pd.DataFrame): The input DataFrame containing the data to calculate coefficients.</span>
<span class="sd">            variance_tuple_dictionary (dict): A dictionary where keys are variance components, and values</span>
<span class="sd">                                      are tuples of grouping variables.</span>
<span class="sd">            missing_data (bool): Whether to drop rows with NaN values before calculations. Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A square DataFrame where the rows and columns represent variance components,</span>
<span class="sd">                          and the values represent the calculated variance coefficients.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">                    &#39;p&#39;: [1, 1, 2, 2],</span>
<span class="sd">                    &#39;h&#39;: [1, 2, 1, 2],</span>
<span class="sd">                    &#39;i&#39;: [1, 2, 1, 2],</span>
<span class="sd">                    &#39;Response&#39;: [0.1, 0.2, 0.3, 0.4]</span>
<span class="sd">                })</span>
<span class="sd">            &gt;&gt;&gt; variance_tup_dict = {</span>
<span class="sd">                    &#39;p&#39;: (&#39;p&#39;,),</span>
<span class="sd">                    &#39;h&#39;: (&#39;h&#39;,),</span>
<span class="sd">                    &#39;i:h&#39;: (&#39;i&#39;, &#39;h&#39;),</span>
<span class="sd">                    &#39;p x h&#39;: (&#39;p&#39;, &#39;h&#39;),</span>
<span class="sd">                    &#39;p x (i:h)&#39;: (&#39;p&#39;, &#39;i&#39;, &#39;h&#39;),</span>
<span class="sd">                    &#39;mean&#39;: ()</span>
<span class="sd">                }</span>
<span class="sd">            &gt;&gt;&gt; self._create_variance_coefficients_table()</span>
<span class="sd">                     p      h    i:h  p x h  p x (i:h)  mean</span>
<span class="sd">            p        n      ...   ...   ...       ...     n</span>
<span class="sd">            h        ...    n     ...   ...       ...     n</span>
<span class="sd">            i:h      ...    ...   n     ...       ...     n</span>
<span class="sd">            p x h    ...    ...   ...   n         ...     n</span>
<span class="sd">            p x (i:h) ...   ...   ...   ...       n       n</span>
<span class="sd">            mean     ...    ...   ...   ...       1       n</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Step 0: Optionally drop rows with NaN values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_data</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Initialize the square DataFrame with variance components as both rows and columns</span>
        <span class="n">variance_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">variance_components</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">variance_components</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>

        <span class="c1"># Step 1: Compute variance coefficients for each pair of variance components</span>
        <span class="k">for</span> <span class="n">row_facet</span> <span class="ow">in</span> <span class="n">variance_components</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col_variance</span> <span class="ow">in</span> <span class="n">variance_components</span><span class="p">:</span>
                <span class="n">grouping_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">[</span><span class="n">col_variance</span><span class="p">])</span>
                <span class="n">facets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">[</span><span class="n">row_facet</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">row_facet</span><span class="p">,</span> <span class="n">col_variance</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_variance_coefficients</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">grouping_vars</span><span class="o">=</span><span class="n">grouping_vars</span><span class="p">,</span>
                    <span class="n">facets</span><span class="o">=</span><span class="n">facets</span>
                <span class="p">)</span>

        <span class="c1"># Check that the dtype is float64</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Round the values to 4 decimal places</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_regression_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a regression matrix for variance component estimation.</span>

<span class="sd">        This method constructs a regression matrix by combining variance coefficients</span>
<span class="sd">        with their corresponding T values. The resulting matrix is used for solving the</span>
<span class="sd">        system of equations to estimate variance components.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A DataFrame containing the regression matrix, where rows correspond</span>
<span class="sd">                          to facets and columns represent variance coefficients and T values.</span>

<span class="sd">        Example:</span>
<span class="sd">            Index: [&#39;facet1&#39;, &#39;facet2&#39;]</span>
<span class="sd">            Columns: [&#39;Variance1&#39;, &#39;Variance2&#39;, ..., &#39;T&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a copy of the variance coefficients table</span>
        <span class="n">regression_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_coeffs_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Add a column for T values using the T dictionary</span>
        <span class="n">regression_df</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">facet</span><span class="p">]</span> <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">regression_df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">regression_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate variance components using a regression matrix.</span>

<span class="sd">        This method solves a linear system of equations where the regression matrix</span>
<span class="sd">        represents the coefficients of variance components and the right-hand side</span>
<span class="sd">        vector corresponds to the T values. The solution gives the variance components,</span>
<span class="sd">        which are stored in the ANOVA table.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Construct the regression matrix using `_create_regression_matrix`.</span>
<span class="sd">            2. Solve the linear system using `np.linalg.solve`.</span>
<span class="sd">            3. Store the calculated variance components in the ANOVA table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Create the regression matrix</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_regression_matrix</span><span class="p">()</span>

        <span class="c1"># Step 2: Extract the coefficient matrix (A) and right-hand side vector (B)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># Coefficient matrix</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># Right-hand side vector</span>

        <span class="c1"># Step 3: Solve the system of linear equations</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>  <span class="c1"># Variance components</span>

        <span class="c1"># Step 4: Round the solution for clarity</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Step 5: Update the DataFrame with calculated variances</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>

        <span class="c1"># Step 6: Store the ANOVA table for future use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="Design.calculate_anova">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.calculate_anova">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_anova</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs analogous ANOVA calculations using Henderson 1953 Method 1.</span>
<span class="sd">        Determines the variance components from variance coefficients and</span>
<span class="sd">        uncorrected sum of squares (T values) for each facet, iteractions, and means.</span>

<span class="sd">        This method executes the steps necessary to estimate variance components based</span>
<span class="sd">        on Generalizability Theory. This method does not require corrected Sum of Squares or Mean Squares,</span>
<span class="sd">        and thus they are not calculated. It also does not calculate hypothesis tests or F-statistics,</span>
<span class="sd">        as these are not relevant in G-Theory.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Calculate the T values using `_calculate_T_values`.</span>
<span class="sd">            2. Create the variance coefficients table with `_create_variance_coefficients_table`.</span>
<span class="sd">            3. Estimate variance components using `_calculate_variance`.</span>

<span class="sd">        Note:</span>
<span class="sd">            - This method does not require and does not calculate Sum of Squares or Mean Squares.</span>
<span class="sd">            - This method emphasizes variance component estimation over hypothesis testing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Calculate the T values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_T_values</span><span class="p">()</span>

        <span class="c1"># Step 2: Create the variance coefficients table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_variance_coefficients_table</span><span class="p">()</span>

        <span class="c1"># Step 3: Estimate the variance components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_variance</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_tau_facets</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">facet_of_differentiation_tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the appropriate facets to include in the tau calculation for generalizability coefficients.</span>

<span class="sd">        This function identifies the primary facet of differentiation and any lower-order interaction facets</span>
<span class="sd">        that are subsets of the current facet tuple (`facet_of_differentiation_tup`) and exist in the</span>
<span class="sd">        `variance_tup_dict`. The resulting list is used in calculations for generalizability coefficients.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            facet_of_differentiation (str): The primary facet for which tau is being calculated.</span>
<span class="sd">            facet_of_differentiation_tup (tuple): Tuple representing the facet&#39;s structure (e.g., nested or crossed facets).</span>
<span class="sd">            variance_tup_dict (dict): Dictionary where keys are facet names and values are tuples representing</span>
<span class="sd">                                      the structure of their variance components.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of facets to include in the tau calculation. Includes the primary facet and any valid</span>
<span class="sd">                  lower-order interaction facets.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; variance_tup_dict = {&#39;p&#39;: (&#39;p&#39;,), &#39;pi&#39;: (&#39;p&#39;, &#39;i&#39;), &#39;mean&#39;: ()}</span>
<span class="sd">            &gt;&gt;&gt; self._get_tau_facets(df, &#39;pi&#39;, (&#39;p&#39;, &#39;i&#39;), variance_tup_dict)</span>
<span class="sd">            [&#39;pi&#39;, &#39;p&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the tau facets with the primary facet of differentiation</span>
        <span class="n">tau_facets</span> <span class="o">=</span> <span class="p">[</span><span class="n">facet_of_differentiation</span><span class="p">]</span>

        <span class="c1"># Check for interactions if the facet tuple has more than one element</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">facet_of_differentiation_tup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check if each facet in the tuple is a primary subscript (Cardinet et al. 1981, Extension of Generalizability Theory)</span>
            <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">facet_of_differentiation_tup</span><span class="p">:</span>
                <span class="c1"># if the facet is in a variance tuple of length 1, it is a primary subscript</span>
                <span class="k">if</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">variance_tup_dict</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="p">[</span><span class="n">facet</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tau_facets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">facet</span><span class="p">)</span>
            
            
            <span class="c1"># # Generate all potential lower-order subsets of the facet tuple</span>
            <span class="c1"># for i in range(len(facet_of_differentiation_tup) - 1, 0, -1):</span>
            <span class="c1">#     # Generate all combinations of the tuple elements of length i</span>
            <span class="c1">#     combos = {frozenset(combo) for combo in combinations(facet_of_differentiation_tup, i)}</span>

            <span class="c1">#     # Check if these combinations exist in the variance dictionary</span>
            <span class="c1">#     for key, variance_tup in variance_tup_dict.items():</span>
            <span class="c1">#         if len(variance_tup) == i and frozenset(variance_tup) in combos:</span>
            <span class="c1">#             tau_facets.append(key)</span>

        <span class="k">return</span> <span class="n">tau_facets</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_tau</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">tau_facets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tau_facets</span><span class="p">,</span> <span class="s1">&#39;Variance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tau</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_big_delta_facets</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tau_facets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>

        <span class="c1"># Any variance component not in the tau facets is part of the Delta (Δ) calculation</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tau_facets</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_big_delta</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">big_delta_facets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
            <span class="n">levels_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

        <span class="n">Delta</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># for facet in variance_tup_dict.keys():</span>
        <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">big_delta_facets</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">facet</span><span class="p">,</span> <span class="s1">&#39;Variance&#39;</span><span class="p">]</span>

            <span class="n">Delta</span> <span class="o">+=</span> <span class="n">variance</span> <span class="o">*</span> <span class="n">levels_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">facet_of_differentiation</span><span class="p">,</span> <span class="n">facet</span><span class="p">]</span>  <span class="c1"># levels_df returns 1 / level so variance * levels_df is equivalent to variance / alpha</span>

        <span class="k">return</span> <span class="n">Delta</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_phi_squared</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">levels_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
            <span class="n">error_variance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Phi (Φ) coefficient for a given facet of differentiation.</span>
<span class="sd">    </span>
<span class="sd">        The phi-squared coefficient quantifies the proportion of total variance attributable</span>
<span class="sd">        to the specified facet of differentiation. It is calculated using the variance components</span>
<span class="sd">        and levels from the provided dictionaries.</span>
<span class="sd">    </span>
<span class="sd">        Parameters:</span>
<span class="sd">            df (pd.DataFrame): A DataFrame containing variance components with a &#39;Variance&#39; column.</span>
<span class="sd">                               It should include rows and columns corresponding to facets of differentiation.</span>
<span class="sd">            facet_of_differentiation (str): The facet for which Φ is being calculated.</span>
<span class="sd">            variance_tup_dict (dict): A dictionary where keys are facet names and values are tuples</span>
<span class="sd">                                      representing the facets that contribute to the variance.</span>
<span class="sd">            levels_df (pd.DataFrame): A DataFrame where indices are facet names and values are their respective</span>
<span class="sd">                                levels coefficient (1 / levels).</span>
<span class="sd">            error_variance (bool, optional): If True, prints detailed information about</span>
<span class="sd">                                    the error variances for Tau (τ) and Delta (Δ) during</span>
<span class="sd">                                    the calculation. Default is False.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: The calculated Φ coefficient for the specified facet of differentiation.</span>
<span class="sd">    </span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; df = pd.DataFrame({&#39;Variance&#39;: [1.0, 0.5, 0.2]}, index=[&#39;p&#39;, &#39;i&#39;, &#39;mean&#39;])</span>
<span class="sd">            &gt;&gt;&gt; variance_tup_dict = {&#39;p&#39;: (&#39;p&#39;,), &#39;i&#39;: (&#39;i&#39;,), &#39;mean&#39;: ()}</span>
<span class="sd">            &gt;&gt;&gt; levels_df = pd.DataFrame({&#39;p&#39;: [0.5, 0.2, 1.0], &#39;i&#39;: [0.2, 0.5, 1.0], &#39;mean&#39;: [1.0, 1.0, 1.0]})</span>
<span class="sd">            &gt;&gt;&gt; self._calculate_phi_squared(df, &#39;p&#39;, variance_tup_dict, levels_dict)</span>
<span class="sd">            0.8333</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Extract the tuple for the facet of differentiation</span>
        <span class="n">facet_of_differentiation_tup</span> <span class="o">=</span> <span class="n">variance_tup_dict</span><span class="p">[</span><span class="n">facet_of_differentiation</span><span class="p">]</span>

        <span class="c1"># Step 2: Extract the variance (τ) for the facet of differentiation</span>
        <span class="n">tau_facets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tau_facets</span><span class="p">(</span>
            <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet_of_differentiation</span><span class="p">,</span>
            <span class="n">facet_of_differentiation_tup</span><span class="o">=</span><span class="n">facet_of_differentiation_tup</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span>
        <span class="p">)</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_tau</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">tau_facets</span><span class="p">)</span>

        <span class="c1"># Step 3: Initialize the Delta List (error variances) and calculate the Delta (Δ) value</span>
        <span class="n">Delta_facets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_big_delta_facets</span><span class="p">(</span>
            <span class="n">tau_facets</span><span class="o">=</span><span class="n">tau_facets</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span>
        <span class="p">)</span>

        <span class="n">Delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_big_delta</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet_of_differentiation</span><span class="p">,</span>
            <span class="n">big_delta_facets</span><span class="o">=</span><span class="n">Delta_facets</span><span class="p">,</span>
            <span class="n">levels_df</span><span class="o">=</span><span class="n">levels_df</span>
        <span class="p">)</span>

        <span class="c1"># Step 4: Calculate Φ using the tau and Delta values</span>
        <span class="n">phi_squared</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">/</span> <span class="p">(</span><span class="n">tau</span> <span class="o">+</span> <span class="n">Delta</span><span class="p">)</span>

        <span class="c1"># Step 5: Print Tau and Delta values for deeper insight</span>
        <span class="k">if</span> <span class="n">error_variance</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Φ error variances for Tau (τ) and Delta (Δ):&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Tau (τ) facets: </span><span class="si">{</span><span class="n">tau_facets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Tau (τ): </span><span class="si">{</span><span class="n">tau</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Delta (Δ) facets: </span><span class="si">{</span><span class="n">Delta_facets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Delta (Δ): </span><span class="si">{</span><span class="n">Delta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">phi_squared</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_little_delta_facets</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tau_facets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">facet_of_differentiation_tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>

        <span class="c1"># Initialize the delta facets</span>
        <span class="n">little_delta_facets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">facet</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Skip entries that don&#39;t contribute to delta calculation:</span>
            <span class="c1"># 1. Mean facet</span>
            <span class="c1"># 2. Facet of differentiation itself</span>
            <span class="c1"># 3. Facets with fewer elements than facet of differentiation</span>
            <span class="c1"># 4. Facets already included in tau calculation</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">facet</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span> <span class="ow">or</span>
                    <span class="n">facet</span> <span class="o">==</span> <span class="n">facet_of_differentiation</span> <span class="ow">or</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">facet_of_differentiation_tup</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">facet</span> <span class="ow">in</span> <span class="n">tau_facets</span><span class="p">):</span>
                <span class="k">continue</span>
            
            <span class="c1"># Debugging output</span>
            <span class="c1"># print(f&quot;delta (δ) Facet: {facet}, Tuple: {tup}&quot;)</span>

            <span class="c1"># Check if any elements of the differentiation tuple are in the current tuple</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span> <span class="ow">in</span> <span class="n">tup</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">facet_of_differentiation_tup</span><span class="p">):</span>
                <span class="n">little_delta_facets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">facet</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">little_delta_facets</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_little_delta</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">little_delta_facets</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
            <span class="n">levels_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># for facet in variance_tup_dict.keys():</span>
        <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">little_delta_facets</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">facet</span><span class="p">,</span> <span class="s1">&#39;Variance&#39;</span><span class="p">]</span>

            <span class="n">delta</span> <span class="o">+=</span> <span class="n">variance</span> <span class="o">*</span> <span class="n">levels_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">facet_of_differentiation</span><span class="p">,</span> <span class="n">facet</span><span class="p">]</span>  <span class="c1"># levels_df returns 1 / level so variance * levels_df is equivalent to variance / alpha_star</span>

        <span class="k">return</span> <span class="n">delta</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_rho_squared</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">levels_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">error_variance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the rho-squared (ρ²) coefficient for a given facet of differentiation.</span>
<span class="sd">    </span>
<span class="sd">        The rho-squared coefficient measures the proportion of total variance attributable to</span>
<span class="sd">        the specified facet of differentiation, considering only facets nested within the</span>
<span class="sd">        differentiation tuple.</span>
<span class="sd">    </span>
<span class="sd">        Parameters:</span>
<span class="sd">            df (pd.DataFrame): A DataFrame containing variance components with a &#39;Variance&#39; column.</span>
<span class="sd">                               It should include rows and columns corresponding to facets of differentiation.</span>
<span class="sd">            facet_of_differentiation (str): The facet for which ρ² is being calculated.</span>
<span class="sd">            variance_tup_dict (dict): A dictionary where keys are facet names and values are tuples</span>
<span class="sd">                                      representing the facets that contribute to the variance.</span>
<span class="sd">            levels_df (pd.DataFrame): A DataFrame where indices are facet names and values are their respective</span>
<span class="sd">                                levels coefficient (1 / levels).</span>
<span class="sd">            error_variance (bool, optional): If True, prints detailed information about</span>
<span class="sd">                                    the error variances for Tau (τ) and delta (δ) during</span>
<span class="sd">                                    the calculation. Default is False.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: The calculated ρ² coefficient for the specified facet of differentiation.</span>
<span class="sd">    </span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; df = pd.DataFrame({&#39;Variance&#39;: [1.0, 0.5, 0.2]}, index=[&#39;p&#39;, &#39;i&#39;, &#39;mean&#39;])</span>
<span class="sd">            &gt;&gt;&gt; variance_tup_dict = {&#39;p&#39;: (&#39;p&#39;,), &#39;i&#39;: (&#39;p&#39;, &#39;i&#39;), &#39;mean&#39;: ()}</span>
<span class="sd">            &gt;&gt;&gt; levels_dict = pd.DataFrame({&#39;p&#39;: [0.5, 0.2, 1.0], &#39;i&#39;: [0.2, 0.5, 1.0], &#39;mean&#39;: [1.0, 1.0, 1.0]})</span>
<span class="sd">            &gt;&gt;&gt; self._calculate_rho_squared(df, &#39;p&#39;, variance_tup_dict, levels_dict)</span>
<span class="sd">            0.8333</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Extract the tuple for the facet of differentiation</span>
        <span class="n">facet_of_differentiation_tup</span> <span class="o">=</span> <span class="n">variance_tup_dict</span><span class="p">[</span><span class="n">facet_of_differentiation</span><span class="p">]</span>

        <span class="c1"># Step 2: Extract the variance (τ) for the facet of differentiation and any lower interaction facets within the tuple</span>
        <span class="n">tau_facets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tau_facets</span><span class="p">(</span>
            <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet_of_differentiation</span><span class="p">,</span>
            <span class="n">facet_of_differentiation_tup</span><span class="o">=</span><span class="n">facet_of_differentiation_tup</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span>
        <span class="p">)</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_tau</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">tau_facets</span><span class="p">)</span>

        <span class="c1"># Step 3: Get the facets for the delta calculation</span>
        <span class="n">little_delta_facets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_little_delta_facets</span><span class="p">(</span>
            <span class="n">tau_facets</span><span class="o">=</span><span class="n">tau_facets</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet_of_differentiation</span><span class="p">,</span>
            <span class="n">facet_of_differentiation_tup</span><span class="o">=</span><span class="n">facet_of_differentiation_tup</span><span class="p">,</span>
            <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span>
        <span class="p">)</span>

        <span class="c1"># Step 4: Calculate delta (δ) using the variance components and levels_df</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_little_delta</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet_of_differentiation</span><span class="p">,</span>
            <span class="n">little_delta_facets</span><span class="o">=</span><span class="n">little_delta_facets</span><span class="p">,</span>
            <span class="n">levels_df</span><span class="o">=</span><span class="n">levels_df</span>
        <span class="p">)</span>

        <span class="c1"># Step 4: Calculate ρ² using tau and delta values</span>
        <span class="n">rho_squared</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">/</span> <span class="p">(</span><span class="n">tau</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># Step 5: Print Tau (τ) and delta (δ) values for deeper insight</span>
        <span class="k">if</span> <span class="n">error_variance</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ρ² error variances: Tau (τ) and Delta (δ)&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Tau (τ) facets: </span><span class="si">{</span><span class="n">tau_facets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Tau (τ): </span><span class="si">{</span><span class="n">tau</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Delta (δ) facets: </span><span class="si">{</span><span class="n">little_delta_facets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Delta (δ): </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rho_squared</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_g_coeffs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">variance_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
        <span class="n">levels_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
        <span class="n">variance_tup_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">error_variance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the G-coefficients for each facet of differentiation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Initialize the G coefficients DataFrame</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">variance_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;phi^2&#39;</span><span class="p">,</span> <span class="s1">&#39;rho^2&#39;</span><span class="p">]</span>
        <span class="n">g_coeffs_df</span> <span class="o">=</span> <span class="n">variance_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">g_coeffs_df</span> <span class="o">=</span> <span class="n">g_coeffs_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Step 2: Calculate the G coefficients for each facet up until the largest facet</span>
        <span class="n">largest_facet</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">facet</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span> <span class="ow">or</span> <span class="n">facet</span> <span class="o">==</span> <span class="n">largest_facet</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">error_variance</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;-&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">Calculating Φ and ρ² coefficients for facet of differentiation: </span><span class="si">{</span><span class="n">facet</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;-&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="c1"># Calculate the phi-squared coefficient</span>
            <span class="n">g_coeffs_df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">facet</span><span class="p">,</span> <span class="s1">&#39;phi^2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_phi_squared</span><span class="p">(</span>
                <span class="n">variance_df</span><span class="p">,</span> 
                <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet</span><span class="p">,</span>
                <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span><span class="p">,</span>
                <span class="n">levels_df</span><span class="o">=</span><span class="n">levels_df</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="o">=</span><span class="n">error_variance</span>
            <span class="p">)</span>

            <span class="c1"># Calculate the rho-squared coefficient</span>
            <span class="n">g_coeffs_df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">facet</span><span class="p">,</span> <span class="s1">&#39;rho^2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_rho_squared</span><span class="p">(</span>
                <span class="n">variance_df</span><span class="p">,</span> 
                <span class="n">facet_of_differentiation</span><span class="o">=</span><span class="n">facet</span><span class="p">,</span>
                <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span><span class="p">,</span>
                <span class="n">levels_df</span><span class="o">=</span><span class="n">levels_df</span><span class="p">,</span>
                <span class="n">error_variance</span><span class="o">=</span><span class="n">error_variance</span>
            <span class="p">)</span>

        <span class="c1"># Drop any columns that are not &#39;phi^2&#39; or &#39;rho^2&#39;</span>
        <span class="n">g_coeffs_df</span> <span class="o">=</span> <span class="n">g_coeffs_df</span><span class="p">[[</span><span class="s1">&#39;phi^2&#39;</span><span class="p">,</span> <span class="s1">&#39;rho^2&#39;</span><span class="p">]]</span>

        <span class="c1"># Drop any rows with NaN values</span>
        <span class="n">g_coeffs_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Round the values to 4 decimal places</span>
        <span class="n">g_coeffs_df</span> <span class="o">=</span> <span class="n">g_coeffs_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g_coeffs_df</span>

<div class="viewcode-block" id="Design.g_coeffs">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.g_coeffs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">g_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate G-coefficients for various scenarios of fixed and random facets.</span>
<span class="sd">        </span>
<span class="sd">        This method computes rho^2 (relative) and phi^2 (absolute) coefficients for each </span>
<span class="sd">        potential object of measurement in the design. The coefficients quantify the </span>
<span class="sd">        reliability of measurements across different facets.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            **kwargs: Optional keyword arguments.</span>
<span class="sd">                - variance_dictionary (dict): Custom variance components to use.</span>
<span class="sd">                    If provided, values must be non-negative. If not provided, </span>
<span class="sd">                    components from the ANOVA table are used.</span>
<span class="sd">                - levels_df (pd.DataFrame): Custom levels coefficients table.</span>
<span class="sd">                    If not provided, self.levels_coeffs is used or calculated.</span>
<span class="sd">                - variance_tuple_dictionary (dict): Custom variance tuple dictionary.</span>
<span class="sd">                    If not provided, self.variance_tuple_dictionary is used.</span>
<span class="sd">                - d_study (bool): If True, returns the G-coefficients DataFrame directly</span>
<span class="sd">                    instead of storing it in self.g_coeffs_table. Default is False.</span>
<span class="sd">                - error_variance (bool): If True, prints detailed information about</span>
<span class="sd">                    the error variances for Tau (τ), Delta (Δ), and delta (δ) during</span>
<span class="sd">                    the calculation of phi-squared and rho-squared coefficients.</span>
<span class="sd">                    Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame or None: If d_study=True, returns the G-coefficients DataFrame directly.</span>
<span class="sd">            Otherwise, results are stored in self.g_coeffs_table and None is returned.</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If:</span>
<span class="sd">                - ANOVA table hasn&#39;t been calculated and no variance_dictionary is provided</span>
<span class="sd">                - Any variance component is negative</span>
<span class="sd">                - Levels coefficients are invalid (non-square, negative values)</span>
<span class="sd">                - Keys in variance_dictionary don&#39;t match variance_tuple_dictionary</span>
<span class="sd">                - Levels coefficients don&#39;t match variance components</span>
<span class="sd">        </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Negative variance components are automatically set to zero with a warning</span>
<span class="sd">            - The &#39;mean&#39; component is removed from calculations</span>
<span class="sd">            - The method produces a DataFrame with rho^2 and phi^2 values for each facet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ---- Variance Tuple Dictionary kwargs ----</span>
        <span class="c1"># Set the variance tuple dictionary (in case the design has been updated)</span>
        <span class="k">if</span> <span class="s1">&#39;variance_tuple_dictionary&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">variance_tup_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;variance_tuple_dictionary&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Variance tuple dictionary must be a dictionary.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variance tuple dictionary component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not a tuple.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using user-provided variance tuple dictionary&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the default variance tuple dictionary</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using default variance tuple dictionary&quot;</span><span class="p">)</span>
            <span class="n">variance_tup_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span>
            
        <span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        
        <span class="c1"># ---- Variance kwargs ----</span>
        <span class="c1"># Process the variance dictionary</span>
        <span class="k">if</span> <span class="s1">&#39;variance_dictionary&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">variance_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;variance_dictionary&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Variance dictionary must be a dictionary.&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using user-provided variance dictionary&quot;</span><span class="p">)</span>
            
            <span class="c1"># Validate the variance dictionary</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">variance_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not a number.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is negative.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variance dictionary keys do not match the variance tuple dictionary keys. Mismatched keys: </span><span class="si">{</span><span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Convert to DataFrame to match anova_table structure</span>
            <span class="n">variance_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Variance&#39;</span><span class="p">:</span> <span class="n">variance_dict</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check if the ANOVA table has been calculated</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please calculate the ANOVA table using the calculate_anova method before calculating the confidence intervals.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using ANOVA Table Variance Dictionary for Generalizability Coefficients&quot;</span><span class="p">)</span>
            <span class="n">variance_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
        <span class="c1"># Process the variance dictionary and check for matching keys in the variance tuple dictionary</span>
        <span class="n">variance_df</span> <span class="o">=</span> <span class="n">variance_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="n">variance_df</span> <span class="o">=</span> <span class="n">variance_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">variance_df</span><span class="p">[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># Print a warning message and set negative values to 0</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Negative variance components found for </span><span class="si">{</span><span class="n">variance_df</span><span class="p">[</span><span class="n">variance_df</span><span class="p">[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">. Setting to 0.&quot;</span><span class="p">)</span>
            <span class="n">variance_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">variance_df</span><span class="p">[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Check that variance DataFrame indices match the variance tuple dictionary keys</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ANOVA table indices do not match the variance tuple dictionary keys. Mismatched indices: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">variance_tup_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># ---- Level Coefficients kwargs ----            </span>
        <span class="c1"># Check if the levels coefficients have been calculated</span>
        <span class="k">if</span> <span class="s1">&#39;levels_df&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">levels_df</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;levels_df&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">levels_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Levels coefficients must be a DataFrame.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using User Provided Levels Coefficients&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must match the variance components. Mismatched indices: </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must have a square shape with a value for each facet. Mismatched columns: </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">levels_df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must be greater than 0. Minimum value: </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="c1"># check that the levels coefficient indices match the variance components</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must match the variance components. Mismatched indices: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">levels_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_levels_coeffs</span><span class="p">()</span> <span class="c1"># Calculate the levels coefficients</span>
            
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must match the variance components. Mismatched indices: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">variance_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">levels_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span>

        <span class="c1"># ---- Boolean Kwargs ----</span>
        <span class="c1"># Check if error_variance is provided and set to True</span>
        <span class="c1"># error_variance flag is used to print the error variances for Tau (τ), Delta (Δ), and delta (δ)</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;error_variance&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># Default to False if not provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;error_variance must be a boolean value.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Return the G coefficients in a DataFrame if d_study is True</span>
        <span class="c1"># Otherwise, store them in the class attribute</span>
        <span class="n">d_study</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;d_study&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># Default to False if not provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_study</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;d_study must be a boolean value.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate G-coefficients</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_g_coeffs</span><span class="p">(</span>
            <span class="n">variance_df</span><span class="o">=</span><span class="n">variance_df</span><span class="p">,</span> 
            <span class="n">levels_df</span><span class="o">=</span><span class="n">levels_df</span><span class="p">,</span> 
            <span class="n">variance_tup_dict</span><span class="o">=</span><span class="n">variance_tup_dict</span><span class="p">,</span>
            <span class="n">error_variance</span><span class="o">=</span><span class="n">error_variance</span>
        <span class="p">)</span>

        <span class="c1"># Either return the result (in the case of a D-Study)</span>
        <span class="c1"># Or store it in the class attribute to maintain compatibility</span>
        <span class="k">if</span> <span class="n">d_study</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g_coeffs_table</span> <span class="o">=</span> <span class="n">result</span></div>

        
    <span class="c1"># ----------------- D STUDY -----------------</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_process_d_study_helper</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">pseudo_counts_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> 
        <span class="n">variance_tuple_dictionary</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> 
        <span class="n">variance_dictionary</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
        <span class="n">scenario_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to process a single D-Study scenario and append it to the d_study_dict attribute.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            pseudo_counts_df (pd.DataFrame): The pseudo counts DataFrame for this scenario</span>
<span class="sd">            variance_tuple_dictionary (dict): Dictionary mapping components to facet tuples</span>
<span class="sd">            variance_dictionary (dict, optional): Custom variance components to use</span>
<span class="sd">            scenario_label (str, optional): Label for this scenario. If None, generated from pseudo_counts_df</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            None: Results are appended to self.d_study_dict with the scenario label as key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the pseudo levels df</span>
        <span class="n">pseudo_levels_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_levels_coeffs</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">pseudo_counts_df</span><span class="p">,</span>
            <span class="n">variance_tuple_dictionary</span><span class="o">=</span><span class="n">variance_tuple_dictionary</span>
        <span class="p">)</span>
        
        <span class="c1"># Prepare kwargs for g_coeffs</span>
        <span class="n">g_coeffs_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;levels_df&#39;</span><span class="p">:</span> <span class="n">pseudo_levels_df</span><span class="p">,</span>
            <span class="s1">&#39;variance_tuple_dictionary&#39;</span><span class="p">:</span> <span class="n">variance_tuple_dictionary</span><span class="p">,</span>
            <span class="s1">&#39;d_study&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">}</span>
        
        <span class="c1"># Add variance_dictionary if provided</span>
        <span class="k">if</span> <span class="n">variance_dictionary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g_coeffs_kwargs</span><span class="p">[</span><span class="s1">&#39;variance_dictionary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">variance_dictionary</span>
            
        <span class="c1"># Get G-coefficients table</span>
        <span class="n">pseudo_g_coeffs_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_coeffs</span><span class="p">(</span><span class="o">**</span><span class="n">g_coeffs_kwargs</span><span class="p">)</span>
        
        <span class="c1"># Create a label if not provided</span>
        <span class="k">if</span> <span class="n">scenario_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scenario_label</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pseudo_counts_df</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        
        <span class="c1"># Add to d_study_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_study_dict</span><span class="p">[</span><span class="n">scenario_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">pseudo_g_coeffs_table</span>
    
    
<div class="viewcode-block" id="Design.calculate_d_study">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.calculate_d_study">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_d_study</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_study_design</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement a D-Study to determine optimal facet levels based on G-Study variance components.</span>
<span class="sd">        </span>
<span class="sd">        This method examines multiple possible study designs by generating all combinations</span>
<span class="sd">        of the provided facet levels. It calculates G-coefficients for each design scenario</span>
<span class="sd">        using the variance components from a previously conducted G-Study.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            d_study_design (dict): Dictionary where keys are facet names and values are </span>
<span class="sd">                lists of integers representing different numbers of levels to test.</span>
<span class="sd">                For example:</span>
<span class="sd">                {</span>
<span class="sd">                    &#39;person&#39;: [10],        # Only testing 10 persons</span>
<span class="sd">                    &#39;item&#39;: [2, 3],        # Testing either 2 or 3 items</span>
<span class="sd">                    &#39;rater&#39;: [2, 4, 6]     # Testing 2, 4, or 6 raters</span>
<span class="sd">                }</span>
<span class="sd">                This would generate 6 different study designs (1×2×3 combinations).</span>
<span class="sd">                        </span>
<span class="sd">            **kwargs: Optional additional parameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            None: Results are stored in self.d_study_dict, where keys are string</span>
<span class="sd">            representations of each design scenario and values are DataFrames</span>
<span class="sd">            containing the corresponding G-coefficients.</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If d_study_design is not properly formatted or if required</span>
<span class="sd">            precalculations haven&#39;t been performed.</span>
<span class="sd">            </span>
<span class="sd">        Notes:</span>
<span class="sd">            - This method requires that variance components have been calculated via a G-Study</span>
<span class="sd">            - For each design scenario, new levels coefficients are calculated</span>
<span class="sd">            - All facet combinations in the original design must be maintained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if a d_study_design dictionary is provided</span>
        <span class="c1"># If not, check if pseudo_counts_dfs is provided</span>
        <span class="c1"># If neither is provided, raise an error</span>
        <span class="k">if</span> <span class="n">d_study_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ---- Balanced D Study Design ----</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Performing Balanced D-Study Design for the provided designs&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pseudo_counts_dfs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;D-Study design must be provided as a dictionary OR pseudo_counts_dfs: list[pd.DataFrame] must be provided.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_study_design</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;D-Study design must be a dictionary.&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check that each key in d_study_design appears in at least one tuple in variance_tuple_dictionary</span>
            <span class="n">all_facets_in_variance_tuples</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">variance_tuple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">component</span> <span class="o">!=</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>  <span class="c1"># Skip the &#39;mean&#39; component which typically has an empty tuple</span>
                    <span class="n">all_facets_in_variance_tuples</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variance_tuple</span><span class="p">)</span>
                
            <span class="n">unknown_facets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d_study_design</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">all_facets_in_variance_tuples</span>
            <span class="k">if</span> <span class="n">unknown_facets</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Facets </span><span class="si">{</span><span class="n">unknown_facets</span><span class="si">}</span><span class="s2"> in d_study_design are not found in any variance component tuple. Valid facets are: </span><span class="si">{</span><span class="n">all_facets_in_variance_tuples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Check that the values are lists of integers</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d_study_design</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels for facet </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> must be a list of integers.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All levels for facet </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> must be integers.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All levels for facet </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> must be greater than 0.&quot;</span><span class="p">)</span>
                
            <span class="c1"># Get all possible combinations of levels using itertools.product</span>
            <span class="n">study_designs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">facets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d_study_design</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">level_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_study_design</span><span class="p">[</span><span class="n">facet</span><span class="p">]</span> <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">facets</span><span class="p">]</span>
            
            <span class="c1"># Generate all combinations using itertools.product</span>
            <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">level_lists</span><span class="p">):</span>
                <span class="c1"># Create a dictionary for this specific design scenario</span>
                <span class="n">design_scenario</span> <span class="o">=</span> <span class="p">{</span><span class="n">facet</span><span class="p">:</span> <span class="n">level</span> <span class="k">for</span> <span class="n">facet</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">facets</span><span class="p">,</span> <span class="n">combo</span><span class="p">)}</span>
                <span class="n">study_designs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">design_scenario</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">study_design</span> <span class="ow">in</span> <span class="n">study_designs</span><span class="p">:</span>
                <span class="c1"># create a label by turning the study_design dictionary into a string</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">study_design</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
                
                <span class="c1"># Create the pseudo count df</span>
                <span class="c1"># Use the variance tuple dictionary from the G study&#39;s design</span>
                <span class="n">pseudo_counts_df</span> <span class="o">=</span> <span class="n">create_pseudo_df</span><span class="p">(</span>
                    <span class="n">d_study</span><span class="o">=</span><span class="n">study_design</span><span class="p">,</span> 
                    <span class="n">variance_tup_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span>
                <span class="p">)</span>
                                
                <span class="c1"># Use the helper function to process the D-Study scenario</span>
                <span class="c1"># and add to the d_study_dict</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_d_study_helper</span><span class="p">(</span>
                    <span class="n">pseudo_counts_df</span><span class="o">=</span><span class="n">pseudo_counts_df</span><span class="p">,</span>
                    <span class="n">variance_tuple_dictionary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">,</span>
                    <span class="n">scenario_label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ---- Advanced D Study Design ----</span>
            <span class="c1"># Unbalanced, missing, or change in study design type (i.e. crossed to nested)</span>
            <span class="c1"># Must input manual pseudo counts df</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Performing Advanced D-Study Design for the provided designs&quot;</span><span class="p">)</span>
            <span class="n">pseudo_counts_dfs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pseudo_counts_dfs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pseudo_counts_dfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;D-Study design must be provided as a dictionary or pseudo_counts_dfs: list[pd.DataFrame] must be provided.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudo_counts_dfs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pseudo_counts_dfs must be a list of DataFrames.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">pseudo_counts_dfs</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All elements in pseudo_counts_dfs must be DataFrames.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">empty</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">pseudo_counts_dfs</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All DataFrames in pseudo_counts_dfs must be non-empty.&quot;</span><span class="p">)</span>
                
            <span class="c1"># ---- Variance Tuple Dictionary kwargs ----</span>
            <span class="c1"># If study design has been changed from crossed to nested,</span>
            <span class="c1"># set the variance tuple dictionary according to the new design</span>
            <span class="c1"># For example, if the design was Y = µ + p + i + pi</span>
            <span class="c1"># and now it is Y = µ + p + i:p (crossed -&gt; nested)</span>
            <span class="c1"># A new variance tuple dictionary should be provided by the USER removing</span>
            <span class="c1"># {&#39;i&#39;: (&#39;i&#39;,), &#39;pi&#39;: (&#39;p&#39;, &#39;i&#39;)} and adding {&#39;i:p&#39;: (&#39;p&#39;, &#39;i&#39;)}</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;variance_tuple_dictionary&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variance_tuple_dictionary</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;variance_tuple_dictionary&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance_tuple_dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variance_tuple_dictionary must be a dictionary.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Variance tuple dictionary component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not a tuple.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using user-provided variance tuple dictionary&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If design has not changed, use the default variance tuple dictionary</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using default variance tuple dictionary&quot;</span><span class="p">)</span>
                <span class="n">variance_tuple_dictionary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span>
                
            <span class="c1"># validate that the columns (facets) of the pseudo_counts_dfs can be found in the variance_tuple_dictionary tuples</span>
            <span class="n">all_facets_in_variance_tuples</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">variance_tuple</span> <span class="ow">in</span> <span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">component</span> <span class="o">!=</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                    <span class="n">all_facets_in_variance_tuples</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">variance_tuple</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">pseudo_counts_dfs</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">all_facets_in_variance_tuples</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DataFrame columns </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s2"> are not found in any variance component tuple. Valid facets are: </span><span class="si">{</span><span class="n">all_facets_in_variance_tuples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># ---- Variance kwargs ----</span>
            <span class="c1"># Check if the variance dictionary is provided</span>
            <span class="c1"># Variance dictionary should be provided if the study design has changed</span>
            <span class="c1"># As in the variance_tuple_dictionary example above</span>
            <span class="c1"># {&#39;i&#39;: var_i, &#39;pi&#39;: var_pi} should be removed and</span>
            <span class="c1"># a combined variance term, {&#39;i:p&#39;: var_i:p} should be added</span>
            <span class="c1"># If the variance dictionary is not provided, use the default variance dictionary</span>
            <span class="c1"># from the ANOVA table</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;variance_dictionary&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variance_dictionary</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;variance_dictionary&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance_dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variance_dictionary must be a dictionary.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">variance_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not a number.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is negative.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using user-provided variance dictionary&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please calculate the ANOVA table using the calculate_anova method before calculating the confidence intervals.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using ANOVA Table Variance Dictionary for Generalizability Coefficients&quot;</span><span class="p">)</span>
                <span class="n">variance_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="s1">&#39;mean&#39;</span><span class="p">}</span> <span class="c1"># Exclude the mean row</span>
            
            <span class="c1"># Check if the variance components are equal to the variance components</span>
            <span class="c1"># Described by the variance tuple dictionary</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variance dictionary keys do not match the variance tuple dictionary keys. Mismatched keys: </span><span class="si">{</span><span class="n">variance_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">variance_tuple_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1"># Enter the D-Study Loop</span>
            <span class="k">for</span> <span class="n">pseudo_counts_df</span> <span class="ow">in</span> <span class="n">pseudo_counts_dfs</span><span class="p">:</span>
                <span class="c1"># create a label by turning the study_design dictionary into a string</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pseudo_counts_df</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
                
                <span class="c1"># Use the helper function to process the D-Study scenario</span>
                <span class="c1"># and add to the d_study_dict</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_d_study_helper</span><span class="p">(</span>
                    <span class="n">pseudo_counts_df</span><span class="o">=</span><span class="n">pseudo_counts_df</span><span class="p">,</span>
                    <span class="n">variance_tuple_dictionary</span><span class="o">=</span><span class="n">variance_tuple_dictionary</span><span class="p">,</span>
                    <span class="n">variance_dictionary</span><span class="o">=</span><span class="n">variance_dictionary</span><span class="p">,</span>
                    <span class="n">scenario_label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="p">)</span></div>

        
    <span class="c1"># ----------------- Confidence Intervals -----------------</span>
<div class="viewcode-block" id="Design.calculate_confidence_intervals">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.calculate_confidence_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_confidence_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate confidence intervals for means of each facet level.</span>
<span class="sd">        </span>
<span class="sd">        This method computes confidence intervals for individual facets based on </span>
<span class="sd">        variance component analysis using the formula from Cardinet et al. (1976):</span>
<span class="sd">        </span>
<span class="sd">        X ± z_(α/2) × √(σ²)</span>
<span class="sd">        </span>
<span class="sd">        where σ² represents the sum of variance components adjusted by the </span>
<span class="sd">        appropriate levels coefficients.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            alpha (float, optional): Significance level for confidence intervals.</span>
<span class="sd">                Default is 0.05 (producing 95% confidence intervals).</span>
<span class="sd">            **kwargs: Optional keyword arguments.</span>
<span class="sd">                - variance_dictionary (dict): Custom variance components to use.</span>
<span class="sd">                If not provided, components from the ANOVA table are used.</span>
<span class="sd">                - levels_df (pd.DataFrame): Custom levels coefficients table. </span>
<span class="sd">                If not provided, self.levels_coeffs is used or calculated.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            None: Results are stored in self.confidence_intervals</span>
<span class="sd">            </span>
<span class="sd">        Attributes:</span>
<span class="sd">            self.confidence_intervals (dict): Dictionary where keys are facet names and</span>
<span class="sd">                values are DataFrames containing confidence intervals for each level.</span>
<span class="sd">                Each DataFrame contains columns:</span>
<span class="sd">                - lower_bound: Lower CI boundary</span>
<span class="sd">                - mean: Observed mean</span>
<span class="sd">                - upper_bound: Upper CI boundary</span>
<span class="sd">                </span>
<span class="sd">        Notes:</span>
<span class="sd">            - Confidence intervals are not calculated for the facet with the largest</span>
<span class="sd">            dimensionality (typically the interaction term containing all facets).</span>
<span class="sd">            - Negative variance components are automatically set to zero with a warning.</span>
<span class="sd">            - The method requires the ANOVA table to be calculated first unless</span>
<span class="sd">            a custom variance_dictionary is provided.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If alpha is not between 0 and 1, ANOVA hasn&#39;t been calculated,</span>
<span class="sd">                or if invalid parameters are provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the alpha value is between 0 and 1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alpha must be between 0 and 1.&quot;</span><span class="p">)</span>
        <span class="c1"># Check if the alpha value is a number</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alpha must be a number.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        
        <span class="c1"># add the variance components to a dictionary</span>
        <span class="k">if</span> <span class="s1">&#39;variance_dictionary&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">variance_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;variance_dictionary&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variance_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Variance dictionary must be a dictionary.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using User Provided Variance Dictionary&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">variance_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not a number. Please check the variance dictionary and try again.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is negative. Please check the variance dictionary and try again.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Variance component &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in the source of variance. Please check the variance dictionary and try again.&quot;</span><span class="p">)</span>
                
            <span class="c1"># variance_dict = {re.sub(r&quot;\s+&quot;, &quot; &quot;, key.strip().lower()): value for key, value in variance_dict.items()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check if the ANOVA table has been calculated</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please calculate the ANOVA table using the calculate_anova method before calculating the confidence intervals.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using ANOVA Table Variance Dictionary&quot;</span><span class="p">)</span>
            <span class="n">variance_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="s1">&#39;mean&#39;</span><span class="p">}</span> <span class="c1"># Exclude the mean row</span>
            <span class="c1"># Check if any variance components are less than 0</span>
            <span class="n">negative_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">variance_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">negative_keys</span><span class="p">:</span>
                <span class="c1"># Print a warning message and set negative values to 0</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Negative variance components found for </span><span class="si">{</span><span class="n">negative_keys</span><span class="si">}</span><span class="s2">. Setting to 0.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">negative_keys</span><span class="p">:</span>
                    <span class="n">variance_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    
        <span class="c1"># Check if the levels coefficients have been calculated</span>
        <span class="k">if</span> <span class="s1">&#39;levels_df&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using User Provided Levels Coefficients&quot;</span><span class="p">)</span>
            <span class="n">levels_df</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;levels_df&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">levels_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Levels coefficients must be a DataFrame.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must have a square shape with a value for each facet. Mismatched columns: </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">levels_df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must be greater than 0. Minimum value: </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using previously calculated levels coefficients&quot;</span><span class="p">)</span>
            <span class="n">levels_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating levels coefficients&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_levels_coeffs</span><span class="p">()</span> <span class="c1"># Calculate the levels coefficients</span>
            <span class="n">levels_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels_coeffs</span>
            
        <span class="c1"># Check that the levels coefficients match the variance components</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Levels coefficients must match the variance components. Mismatched indices: </span><span class="si">{</span><span class="n">levels_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
           
        <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c1"># Create a dictionary with empty DataFrames as values</span>

        <span class="c1"># Remove the largest facet from the confidence intervals i.e. p x (i:h) since</span>
        <span class="c1"># there will be a single value for each unique combination of the other facets</span>
        <span class="n">max_facet</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">max_facet</span><span class="p">}</span>
        
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">:</span>
            
            <span class="c1"># Sum the variances all other variances divided by the product of the levels of the other facets</span>
            <span class="c1"># Do not include the variance of the facet in question or the level of the facet in question</span>
            <span class="c1"># For example, sigma^2(aBC) = sigma^2(b)/n_b + sigma^2(c)/n_c + sigma^2(bc)/n_b*n_c + sigma^2(ab)/n_b + sigma^2(ac)/n_c + sigma^2(abc)/n_b*n_c</span>
            <span class="n">sigma_squared</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variance_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="n">sigma_squared</span> <span class="o">+=</span> <span class="n">variance_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">*</span> <span class="n">levels_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">var</span><span class="p">]</span>  <span class="c1"># levels_df returns 1 / level so variance * levels_df is equivalent to variance / levels</span>
            
            <span class="c1"># Use the alpha value to get the z_alpha/2 value</span>
            <span class="n">z_alpha</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">z_alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_squared</span><span class="p">)</span>

            <span class="c1"># First, get just the mean in a clean way</span>
            <span class="n">ci_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_tuple_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">response_col</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span>
            <span class="p">})</span>

            <span class="c1"># Rename the column to be clearer</span>
            <span class="n">ci_df</span> <span class="o">=</span> <span class="n">ci_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">response_col</span><span class="p">:</span> <span class="s1">&#39;mean&#39;</span><span class="p">})</span>

            <span class="c1"># Now add the confidence interval columns</span>
            <span class="n">ci_df</span><span class="p">[</span><span class="s1">&#39;lower_bound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_df</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">interval</span>
            <span class="n">ci_df</span><span class="p">[</span><span class="s1">&#39;upper_bound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_df</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">interval</span>

            <span class="c1"># Reorder columns to match your desired output</span>
            <span class="n">ci_df</span> <span class="o">=</span> <span class="n">ci_df</span><span class="p">[[</span><span class="s1">&#39;lower_bound&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;upper_bound&#39;</span><span class="p">]]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_df</span></div>

    
    <span class="c1"># ----------------- Summary Functions -----------------    </span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_summary_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">table</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to print a summary table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;-&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">title</span><span class="si">:</span><span class="s2">^20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;-&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get column widths</span>
        <span class="n">std_width</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">header_widths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Calculate widths: first one is for index, then for each column</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">idx_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">max_idx</span><span class="p">,</span> <span class="n">std_width</span><span class="p">)</span>
        <span class="n">header_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_width</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">max_col_val_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">table</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="n">header_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">max_col_val_len</span><span class="p">,</span> <span class="n">std_width</span><span class="p">))</span>

        <span class="c1"># Print the headers</span>
        <span class="n">formatted_header</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">header</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">width</span><span class="si">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">header</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span> <span class="n">header_widths</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">formatted_header</span><span class="p">)</span>

        <span class="c1"># Print each row</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">row_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">header_widths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">row_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">header_widths</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">row_str</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Design.anova_summary">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.anova_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">anova_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a summary of the ANOVA results, including string indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Print the column headers</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_summary_helper</span><span class="p">(</span><span class="s2">&quot;ANOVA Table&quot;</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="p">)</span></div>


<div class="viewcode-block" id="Design.variance_summary">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.variance_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">variance_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a summary of the variance components.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">variance_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anova_table</span><span class="p">[[</span><span class="s1">&#39;Variance&#39;</span><span class="p">]]</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">variance_table</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_summary_helper</span><span class="p">(</span><span class="s2">&quot;Variance Components&quot;</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">variance_table</span><span class="p">)</span></div>


<div class="viewcode-block" id="Design.g_coeff_summary">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.g_coeff_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">g_coeff_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a summary of the g_coeff results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Adjust the column headers for prettier printing</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_coeffs_table</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">symbol_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rho^2&quot;</span><span class="p">:</span> <span class="s2">&quot;ρ²&quot;</span><span class="p">,</span> <span class="s2">&quot;phi^2&quot;</span><span class="p">:</span> <span class="s2">&quot;Φ&quot;</span><span class="p">}</span>
        <span class="n">adjusted_headers</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span> <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_summary_helper</span><span class="p">(</span><span class="s2">&quot;G Coefficients&quot;</span><span class="p">,</span> <span class="n">adjusted_headers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_coeffs_table</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Design.d_study_summary">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.d_study_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">d_study_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a summary of the D-Study results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">d_study_df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_study_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Adjust the column headers for prettier printing</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;D-Study: </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># Adjust the column headers for prettier printing</span>
            <span class="c1"># Add a blank space for the index column</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_study_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">symbol_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rho^2&quot;</span><span class="p">:</span> <span class="s2">&quot;ρ²&quot;</span><span class="p">,</span> <span class="s2">&quot;phi^2&quot;</span><span class="p">:</span> <span class="s2">&quot;Φ&quot;</span><span class="p">}</span>
            <span class="n">adjusted_headers</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span> <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_summary_helper</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">adjusted_headers</span><span class="p">,</span> <span class="n">d_study_df</span><span class="p">)</span></div>

                
    <span class="c1">## POTENTIAL TODO: Add a D-Study visualization function to visualize the G-Coefficients for different scenarios</span>

<div class="viewcode-block" id="Design.confidence_intervals_summary">
<a class="viewcode-back" href="../../api.html#generalizit.design.Design.confidence_intervals_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">confidence_intervals_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a summary of the confidence intervals for each facet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the percentiles based on alpha</span>
        <span class="n">lower_percentile</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span>
        <span class="n">upper_percentile</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span>
        
        <span class="k">for</span> <span class="n">facet</span><span class="p">,</span> <span class="n">ci_df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_intervals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Create a copy with renamed columns</span>
            <span class="n">display_df</span> <span class="o">=</span> <span class="n">ci_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># Rename columns to show percentiles</span>
            <span class="k">if</span> <span class="s1">&#39;lower_bound&#39;</span> <span class="ow">in</span> <span class="n">display_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;upper_bound&#39;</span> <span class="ow">in</span> <span class="n">display_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">display_df</span> <span class="o">=</span> <span class="n">display_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                    <span class="s1">&#39;lower_bound&#39;</span><span class="p">:</span> <span class="n">lower_percentile</span><span class="p">,</span>
                    <span class="s1">&#39;upper_bound&#39;</span><span class="p">:</span> <span class="n">upper_percentile</span>
                <span class="p">})</span>
            
            <span class="c1"># Handle MultiIndex by converting to string representation</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">display_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
                <span class="c1"># Create string representations for each MultiIndex entry</span>
                <span class="n">index_names</span> <span class="o">=</span> <span class="n">display_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="n">string_indices</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="k">for</span> <span class="n">idx_tuple</span> <span class="ow">in</span> <span class="n">display_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index_names</span><span class="p">,</span> <span class="n">idx_tuple</span><span class="p">)]</span>
                    <span class="n">string_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">))</span>
                
                <span class="c1"># Create new DataFrame with string index</span>
                <span class="n">display_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">display_df</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                    <span class="n">index</span><span class="o">=</span><span class="n">string_indices</span><span class="p">,</span> 
                    <span class="n">columns</span><span class="o">=</span><span class="n">display_df</span><span class="o">.</span><span class="n">columns</span>
                <span class="p">)</span>
            
            <span class="c1"># Prepare headers (include &#39;Group&#39; for the index column)</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Group&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">display_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            
            <span class="c1"># Call the helper function with appropriate title</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_summary_helper</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">int</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="si">}</span><span class="s2">% CI for &#39;</span><span class="si">{</span><span class="n">facet</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">display_df</span><span class="p">)</span></div>
</div>

        
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Tyler Smith.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>